#!/bin/bash

# Script to copy only necessary documentation files to frontend/public/docs
# - OpenAPI HTML docs (original)
# - Only markdown files that are actually referenced/linked

set -e

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color

echo -e "${BLUE}Copying documentation files...${NC}"

# Clean and create target directory
rm -rf public/docs
mkdir -p public/docs

# 1. Copy OpenAPI HTML docs (generated by export_postman_specs.py)
echo -e "${GREEN}âœ“${NC} Copying OpenAPI HTML docs"
mkdir -p public/docs/api/openapi
cp -r ../docs/openapi/docs/* public/docs/api/openapi/

# 2. Copy only referenced markdown files
echo -e "${GREEN}âœ“${NC} Finding and copying referenced markdown files"

# Temporary files to track what to copy
TEMP_DIR=$(mktemp -d)
FILES_TO_COPY="$TEMP_DIR/files_to_copy.txt"
PROCESSED="$TEMP_DIR/processed.txt"

touch "$FILES_TO_COPY"
touch "$PROCESSED"

# Start with main README and section READMEs (entry points)
cat > "$FILES_TO_COPY" << EOF
README.md
get-started/README.md
features/README.md
user-guide/README.md
technical/README.md
api/README.md
examples/README.md
integrations/README.md
security/README.md
screenshots/README.md
videos/README.md
ai agent/ai_agentic.md
ai agent/langfuse_integration.md
EOF

echo -e "${YELLOW}â†’${NC} Following markdown links recursively"

# Process files iteratively
while IFS= read -r file; do
    # Skip if already processed
    if grep -Fxq "$file" "$PROCESSED" 2>/dev/null; then
        continue
    fi
    
    # Mark as processed
    echo "$file" >> "$PROCESSED"
    
    # Skip if file doesn't exist
    if [ ! -f "../docs/$file" ]; then
        continue
    fi
    
    # Find all markdown links in this file
    current_dir=$(dirname "$file")
    
    # Extract .md links from markdown
    grep -oE '\]\([^)]*\.md\)' "../docs/$file" 2>/dev/null | \
    sed 's/][(]//g' | sed 's/)//g' | \
    while IFS= read -r link; do
        # Resolve relative path safely
        target_dir_path="../docs/$current_dir/$(dirname "$link")"
        
        # Skip if directory doesn't exist (avoids cd errors)
        if [ ! -d "$target_dir_path" ]; then
            continue
        fi
        
        # Resolve absolute paths to check boundaries
        abs_target_dir=$(cd "$target_dir_path" && pwd)
        abs_docs_root=$(cd "../docs" && pwd)
        
        # Skip if the file is outside the docs directory
        if [[ "$abs_target_dir" != "$abs_docs_root"* ]]; then
            continue
        fi
        
        # Construct the resolved path relative to docs root
        abs_file_path="$abs_target_dir/$(basename "$link")"
        resolved="${abs_file_path#$abs_docs_root/}"
        
        # Add to files to copy if not already there
        if [ -f "../docs/$resolved" ] && ! grep -Fxq "$resolved" "$FILES_TO_COPY" 2>/dev/null; then
            echo "$resolved" >> "$FILES_TO_COPY"
        fi
    done
    
done < "$FILES_TO_COPY"

# Copy all found files
file_count=0
sort -u "$FILES_TO_COPY" | while IFS= read -r file; do
    if [ -f "../docs/$file" ]; then
        target_dir="public/docs/$(dirname "$file")"
        mkdir -p "$target_dir"
        cp "../docs/$file" "public/docs/$file"
        ((file_count++)) || true
    fi
done

# For screenshots and videos: use index.md (styled version) instead of README.md
# This keeps GitHub showing README.md while website uses the styled index.md
if [ -f "../docs/screenshots/index.md" ]; then
    cp "../docs/screenshots/index.md" "public/docs/screenshots/README.md"
    echo -e "${GREEN}âœ“${NC} Using styled index.md for screenshots"
fi
if [ -f "../docs/videos/index.md" ]; then
    cp "../docs/videos/index.md" "public/docs/videos/README.md"
    echo -e "${GREEN}âœ“${NC} Using styled index.md for videos"
fi

# Count actual copied files
file_count=$(find public/docs -name "*.md" | wc -l | tr -d ' ')

# Cleanup
rm -rf "$TEMP_DIR"

# 3. Copy security reports if they exist (generated separately)
if [ -f "../docs/security/index.html" ]; then
    echo -e "${GREEN}âœ“${NC} Copying security reports"
    mkdir -p public/docs/security
    cp ../docs/security/index.html public/docs/security/
    [ -f "../docs/security/host-report.json" ] && cp ../docs/security/host-report.json public/docs/security/
    [ -f "../docs/security/server-report.json" ] && cp ../docs/security/server-report.json public/docs/security/
    [ -f "../docs/security/frontend-report.json" ] && cp ../docs/security/frontend-report.json public/docs/security/
    security_status="+ security reports"
else
    security_status="(security reports not generated yet)"
fi

echo -e "${GREEN}âœ“ Documentation copied successfully!${NC}"
echo -e "${BLUE}Copied: 15 OpenAPI HTML files + $file_count markdown files ${security_status}${NC}"

# 4. Generate docs manifest for navigation
echo -e "${YELLOW}â†’${NC} Generating docs manifest..."

# Generate manifest JSON by scanning the copied docs
node -e "
const fs = require('fs');
const path = require('path');

const DOCS_DIR = 'public/docs';

// Section metadata with icons and order
const SECTION_META = {
  'README': { icon: 'ðŸ“š', title: 'Documentation Home', order: 0 },
  'get-started': { icon: 'ðŸš€', title: 'Getting Started', order: 1 },
  'features': { icon: 'âœ¨', title: 'Features', order: 2 },
  'user-guide': { icon: 'ðŸ“–', title: 'User Guide', order: 3 },
  'examples': { icon: 'ðŸ’¡', title: 'Examples', order: 4 },
  'integrations': { icon: 'ðŸ”Œ', title: 'Integrations', order: 5 },
  'faq': { icon: 'â“', title: 'FAQ', order: 6 },
  'technical': { icon: 'ðŸ”§', title: 'Technical Docs', order: 7 },
  'ai agent': { icon: 'ðŸ¤–', title: 'AI Agent', order: 8 },
  'security': { icon: 'ðŸ”', title: 'Security', order: 9 },
  'api': { icon: 'ðŸ“¡', title: 'API Reference', order: 10 },
  'screenshots': { icon: 'ðŸ“¸', title: 'Screenshots', order: 11 },
  'videos': { icon: 'ðŸŽ¬', title: 'Videos', order: 12 },
};

// Subsection metadata for technical docs
const TECH_SUBSECTION_META = {
  'ai': { icon: 'ðŸ¤–', title: 'AI', order: 1 },
  'architecture': { icon: 'ðŸ—ï¸', title: 'Architecture', order: 2 },
  'components': { icon: 'ðŸ“¦', title: 'Components', order: 3 },
  'mcp': { icon: 'ðŸ”®', title: 'MCP Tools', order: 4 },
  'dev': { icon: 'ðŸ› ï¸', title: 'Dev', order: 5 },
};

// Convert filename to readable title
function toTitle(filename) {
  return filename
    .replace(/\.md\$/, '')
    .replace(/^README\$/, 'Overview')
    .replace(/[-_]/g, ' ')
    .replace(/\\b\\w/g, c => c.toUpperCase())
    .replace(/^Mcp /, 'MCP ')
    .replace(/^Ai /, 'AI ')
    .replace(/^Api /, 'API ')
    .replace(/ Id\$/, ' ID')
    .replace(/Jira/, 'JIRA')
    .replace(/Hls/, 'HLS')
    .replace(/Vnc/, 'VNC');
}

// Get all markdown files in a directory
function getMdFiles(dir) {
  if (!fs.existsSync(dir)) return [];
  return fs.readdirSync(dir)
    .filter(f => f.endsWith('.md'))
    .sort((a, b) => {
      // README first, then alphabetically
      if (a === 'README.md') return -1;
      if (b === 'README.md') return 1;
      return a.localeCompare(b);
    });
}

// Get all subdirectories
function getSubdirs(dir) {
  if (!fs.existsSync(dir)) return [];
  return fs.readdirSync(dir)
    .filter(f => fs.statSync(path.join(dir, f)).isDirectory())
    .filter(f => !f.startsWith('.') && f !== 'openapi');
}

// Build section children
function buildChildren(sectionPath, urlPrefix) {
  const children = [];
  const files = getMdFiles(sectionPath);
  const subdirs = getSubdirs(sectionPath);
  
  // Add files
  files.forEach(file => {
    const name = file.replace('.md', '');
    const docPath = name === 'README' ? urlPrefix : urlPrefix + '/' + name;
    children.push({
      title: toTitle(file),
      path: docPath
    });
  });
  
  // Add subdirectories
  subdirs.forEach(subdir => {
    const subPath = path.join(sectionPath, subdir);
    const subFiles = getMdFiles(subPath);
    const subSubdirs = getSubdirs(subPath);
    
    if (subFiles.length > 0 || subSubdirs.length > 0) {
      const meta = TECH_SUBSECTION_META[subdir] || { icon: '', title: toTitle(subdir), order: 99 };
      const subChildren = [];
      
      // Add subdir files (skip README - paths don't work with routing)
      subFiles.forEach(file => {
        if (file === 'README.md') return; // Skip README in nested dirs
        const name = file.replace('.md', '');
        const docPath = urlPrefix + '/' + subdir + '/' + name;
        subChildren.push({
          title: toTitle(file),
          path: docPath
        });
      });
      
      // Handle nested subdirs (like components under architecture)
      subSubdirs.forEach(nestedDir => {
        const nestedPath = path.join(subPath, nestedDir);
        const nestedFiles = getMdFiles(nestedPath);
        
        if (nestedFiles.length > 0) {
          const nestedMeta = TECH_SUBSECTION_META[nestedDir] || { icon: '', title: toTitle(nestedDir), order: 99 };
          // Skip README files in deeply nested dirs
          const nestedChildren = nestedFiles
            .filter(file => file !== 'README.md')
            .map(file => {
              const name = file.replace('.md', '');
              const docPath = urlPrefix + '/' + subdir + '/' + nestedDir + '/' + name;
              return { title: toTitle(file), path: docPath };
            });
          
          if (nestedChildren.length > 0) {
            subChildren.push({
              title: (nestedMeta.icon ? nestedMeta.icon + ' ' : '') + nestedMeta.title,
              children: nestedChildren
            });
          }
        }
      });
      
      if (subChildren.length > 0) {
        children.push({
          title: (meta.icon ? meta.icon + ' ' : '') + meta.title,
          children: subChildren
        });
      }
    }
  });
  
  return children;
}

// Build the manifest
const manifest = { docs: [] };

// Get top-level sections
const topLevelDirs = getSubdirs(DOCS_DIR);
const sections = [];

// Add root README if exists
if (fs.existsSync(path.join(DOCS_DIR, 'README.md'))) {
  sections.push({
    title: SECTION_META['README'].icon + ' ' + SECTION_META['README'].title,
    path: '/docs/README',
    section: 'root',
    order: SECTION_META['README'].order
  });
}

// Process each section
topLevelDirs.forEach(dir => {
  const sectionPath = path.join(DOCS_DIR, dir);
  const meta = SECTION_META[dir] || { icon: 'ðŸ“„', title: toTitle(dir), order: 99 };
  const urlPrefix = '/docs/' + dir;
  
  const children = buildChildren(sectionPath, urlPrefix);
  
  if (children.length > 0) {
    sections.push({
      title: meta.icon + ' ' + meta.title,
      path: urlPrefix,
      section: dir,
      order: meta.order,
      children: children
    });
  }
});

// Sort by order
sections.sort((a, b) => a.order - b.order);

// Remove order field from output
sections.forEach(s => delete s.order);

manifest.docs = sections;

// Write manifest
fs.writeFileSync(path.join(DOCS_DIR, 'docs-manifest.json'), JSON.stringify(manifest, null, 2));
console.log('Generated docs-manifest.json with ' + sections.length + ' sections');
"

echo -e "${GREEN}âœ“ Docs manifest generated!${NC}"
